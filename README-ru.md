dinDoctrineExtraPlugin for Symfony 1.3/1.4
==========================================

Документацию на английском смотрите в README.md

Краткая информация о плагине
----------------------------
Плагин собирает в себе различные надстройки над Doctrine в Symfony, такие как генераторы моделей,
бихевиоры, пейджер, виджеты и т.д.

Основное назначение плагина - гибкое управление генерацией моделей и добавление дополнительной
функциональности для кастомизации генерации и увеличения гибкости/функциональности получаемого кода.

Ключевое достоинство плагина - увеличение гибкости плагинов и увеличение функциональности
генерируемого кода (в основном форм).

Генератор модели
----------------
Плагин содержит измененные шаблоны форм и собственно надстройку над генераторами моделей, форм
и фильтров.
Управление генерацией модели происходит через модификацию массива данных, полученного в результате
чтения файлов schema.yml. Для этого после чтения и объединения схем структуры данных, прописанных
в плагинах и проекте, полученный массив проходит обработку специально написанным для этой цели
конфигуратором, управляющимся собственной, аналогичной структурой конфигов model.yml.
Что это дает:
1. Мы можем установить глобальные настройки генерации в отдельном проекте. Например отключить
бихевиор i18n во всех моделях, где он присутствует, одной строчкой в конфигурационном файле, либо
поменять класс виджета для всех полей одного типа (или названия).
2. Мы можем управлять стратегией генерации классов форм и фильтров.
3. Мы можем "выключать", т.е. удалять из конечной генерируемой схемы модели, поля, связи, индексы
и бихевиоры. Причем "выключить" можно как в целом, так и отдельно в конкретной части модели -
например исключить некоторые не нужные поля из форм, либо фильтров.
4. Мы можем управлять и наращивать дополнительную функциональность генерируемых форм. Например
сейчас поддерживается автоматический эмбед i18n форм и автоматическое добавление методов для работы
с древовидными структурами (Nested Sets).
5. Мы можем указывать для каждого поля параметры виджетов и валидаторов для генерации в
формах/фильтрах. Фактически это позволяет обойтись без какого-либо добавления кода только базовыми
классами форм/фильтров и небольшим конфиг-файлом. Сгенерированная в Base* форма будет сразу
содержать только нужные вам поля и настроенные виджеты/валидаторы/добавленные методы.
6. Мы получаем красивые сгенерированные классы с опрятными шапками (которые тоже берутся из
отдельного конфигурационного файла).

Конфигурационные файлы model.yml содержат максимально лаконичные команды и следуют принципу
минимизации действий для получения результата.

Установка
---------
После копирования файлов плагина в директорию plugins/ проекта (либо фреймворка, если вы планируете
использовать его в нескольких проектах) и включения плагина в конфигурационном файле проекта(ов),
вам понадобится добавить в этот же конфигурационный файл (config/ProjectConfiguration.class.php)
еще один метод, для настройки генераторов (либо изменить, если такой метод вы туда уже добавляли):

    public function preConfigureDoctrinePlugin( $options = array() )
    {

        sfConfig::set( 'doctrine_model_builder_options', array_merge(
            array( 'baseTableClassName' => 'dinDoctrineTable', 'suffix' => '.php' ),
            $options
        ) );

    }

*Я использую при генерации суффикс ".php", без "class", поскольку практического смысла в этом
суффиксе не вижу, при этом длину названия файлов он увеличивает, а следовательно и занимаемую
оперативную память при подгрузке кеша автолоадера с тысячами файлов, что сказывается на расходе
ресурсов сервера и производительности. Вы можете не указывать этот параметр или изменить его на
дефолтный ".class.php"*

Далее, в директории lib/ проекта вам необходимо создать поддиректорию config/, в которой создать
два файла, пока что пустых: sign.yml и model.yml. Конфиг sign отвечает за генерируемые заголовки
в файлах, вы можете оформлять все генерируемые файлы как вам заблагорассудится, помещать любые
комментарии, лицензионные соглашения и прочее. Подробнее о структуре файла ниже. Файл model.yml
задает глобальные настройки генерации моделей, форм и фильтров. О его структуре так же ниже.

На этом установку можно считать законченой.

Настройка плагина и Структура конфигурационных файлов
-----------------------------------------------------
Для начала о небольшом файле sign.yml. Вот его примерный вид:

    header:
        php:    "/*\n * This file is really cool file.\n * (c) 2010 Vasya Pupkind\n * All rights reserved.\n */"
        yml:    "# This file is really cool file.\n# (c) 2010 Vasya Pupkind\n# All rights reserved."

    pluginHeader:
        php:    "/*\n * This file is part of the #pluginName# package.\n * (c) 2010 Vasya Pupkind\n * All rights reserved.\n */"
        yml:    "# This file is part of the #pluginName# package.\n# (c) 2010 Vasya Pupkind\n# All rights reserved."

    name:       'Your_Project_Name_Here'
    author:     'Vasya Pupkind <vasyok@pupkind.com>'

*"\n" указывают на перевод строки, #pluginName# будет заменено названием плагина автоматически.*

Теперь про настройки модели. Рассматриваем файл lib/config/model.yml проекта, по секциям:

**Секция classes**. Управляет стратегией генерации классов, их структурой. По умолчанию там может
содержаться следующее:

    classes:
        form_plugin_strategy:       'exist'     #allow true, false and 'exist', default 'exist'
        filter_plugin_strategy:     'exist'     #allow true, false and 'exist', default 'exist'

Данные два параметра управляют тем, в каких случаях будут генерироваться классы Plugin\* в формах
и фильтрах. Допускается три значения: true, false и 'exist'. При true классы
Plugin\*Form / Plugin\*FormFilter будут генерироваться и учитываться в структуре, при false
соответственно сами классы не генерируются и не учитываются в структуре (т.е. сгенерированный
основной класс наследует сразу базовый, без учета класса плагина), при 'exist' классы в плагинах
опять таки не генерируются, но если соответствующий класс Plugin\* существует - он включается в
структуру наследования. Рекомендуется оставлять 'exist', после чего, если в плагине были ранее
сгенерированы соответствующие классы и они пустые - просто удалить их. Новые не появятся.

**Секция db_options**. Здесь можно указать настройки для БД, чтобы не описывать их в моделях всех
плагинов. Соответствуют стандартным настройкам в Doctrine, поэтому описывать особо нечего.

    db_options:
        collate:                    'utf8_unicode_ci'
        charset:                    'utf8'

**Секция behaviors**. Управляет бихевиорами в генерируемых моделях. Можно глобально отключить
определенные бихевиоры или сменить их название (а соответственно и класс-шаблон).

    behaviors:
        I18n:
            disable:                true    #allow true and false, default false
            name:                   'I18nMod'

Параметр *name* не обязателен, но если указан - во всех моделях, в которые включен данный бихевиор,
при генерации имя бихевиора будет изменено на указанное. При добавлении параметра *disable* со
значением true данный бихевиор будет игнорироваться в конфигурации моделей и в сгенерированных
классах не появится.

**Секция filters**. Управляет генерацией виджетов и других элементов фильтров по-умолчанию.
Аналогично устроена секция **forms**.

    filters:
        widgets:
            timestamp:
                class:              'dinWidgetFormFilterJqueryDate'
                options:
                    from_date:      'new dinWidgetFormJqueryDate()'
                    to_date:        'new dinWidgetFormJqueryDate()'
                    template:       null
            integer:
                class:              'dinWidgetFormNumberRange'
                options:
                    min:            'new sfWidgetFormInput()'
                    max:            'new sfWidgetFormInput()'
                    template:       null
            float:
                class:              'dinWidgetFormNumberRange'
                options:
                    min:            'new sfWidgetFormInput()'
                    max:            'new sfWidgetFormInput()'
                    template:       null
        validators:
            timestamp:
                class:              'dinValidatorFormFilterDate'
                options:
                    format:         "'dd/mm/yy'"

Данная секция позволяет глобально переопределить виджеты и валидаторы, а также их опции для любого
типа полей. В данном примере выше "timestamp", "integer" и "float" - это и есть типы полей, которые
берутся из модели. Отключить любую генерирующуюся опцию можно установкой ее значения в null. В этом
возникает необходимость, когда вы меняете виджет на свой и ваш виджет не принимает некоторых опций,
генерирующихся по-умолчанию для этого типа виджета.

**Секция forms**. Смотри секцию *filters* выше.

**Секция presets**. Управляет преднастроенными конфигурациями виджетов/валидаторов и их сочетаний.
Облегчает конфигурирование и уменьшает размер конфигурационных файлов.

    presets:
        tmcSimply:
            form:
                widget:
                    class:          'dinWidgetFormTextareaTinymce'
                    options:
                        theme:      "'simple'"
                        width:      '500'
                        height:     '200'
                        config:     "'setup:function(ed){ed.onChange.add(function(ed){tinyMCE.triggerSave();});}'"

Для чего это нужно? Скажем, у вас в части форм есть поля типа textarea, в которые вы хотите
вставить wisywig-редактор. При этом, часть полей textarea в проекте вы хотите оставить обычными.
Для этого вы создаете именованный пресет, в который включаете все, что нужно, а после в конфигурации
соответствующей формы просто ссылаетесь на него, не копируя из раза в раз одни и те же параметры для
каждой формы, где вы хотите поместить такое поле. В примере показан пресет для поля с TinyMce.

Собственно в основном файле model.yml больше ничего быть не должно.

Далее, если у вас уже есть конфигцрации моделей (schema.yml), то вы можете написать для них правила
генерации форм, фильтров, виджетов и т.д., а также изменить в генерируемых моделях все, что захотите.

Если вы создаете плагин, то в его директорию config можно также поместить model.yml, например, чтобы
отключить генерацию ненужных классов форм/фильтров и не прописывать этого в каждом проекте, который
будет использовать этот плагин.

Секций у такого файла может быть всего три: *models*, *forms* и *filters*. Все они содержат
параметры для конкретных моделей.

    filters:

        YourModelTranslation:
            disable:                true

        OtherModelMany2Many:
            disable:                true

    forms:

        DinMenuItem:
            fields:
                root_id:
                    disable:            true
                lft:
                    disable:            true
                rgt:
                    disable:            true
                level:
                    disable:            true

                menu_id:
                    widget:
                        class:          'sfWidgetFormInputHidden'
                        options:
                            model:      null
                            add_empty:  null
                            label:      null
                parent_id:
                    virtual:            true
                    widget:
                        class:          'sfWidgetFormDoctrineChoice'
                        options:
                            model:      "'DinMenuItem'"
                            order_by:   "array( 'root_id, lft', '' )"
                            method:     "'getIndentedName'"
                            label:      "'formLabels.parent'"
                            query:      "Doctrine::getTable( 'DinMenuItem' )->getItemQuery()"
                    validator:
                        class:          'sfValidatorDoctrineChoice'
                        options:
                            required:   'false'
                            model:      "'DinMenuItem'"


В примере отключена генерация фильтров для I18n и м-м, которые все равно никогда не используются.
Соответственно не будут сгенерированы ни базовые классы фильтров соответствующих моделей, ни
основные. Здесь же можно менять типы виджетов для определенных полей, исключать ненужные поля из
форм или добавлять виртуальные поля, которых нет в модели, но они нужны в форме/фильтре и т.д. Над
лаконичностью описаний опций я еще работаю, но пример выше - работает уже сейчас.

Если плагин не ваш, либо вы хотите переопределить его работу в конкретном проекте, вы добавляете в
директорию lib/config вашего проекта поддиректорию с названием плагина и в нее помещаете опять таки
файл model.yml с аналогичной плагинному структурой, в котором и переопределяете все, что вам нужно.

Использование
-------------

Генерация с использованием данного плагина происходит по неймспейсу "doctrine-ext", в остальном не
отличается от оригинальной. Т.е. вместо
    php symfony doctrine:build --all-classes
достаточно написать
    php symfony doctrine-ext:build --all-classes
чтобы использовались генераторы данного плагина. Переопределить стандартный неймспейс легальными
методами не представляется возможным, так как он также определяется в плагине, а не в самом
фреймворке.

Зависимости
-----------
* [Symfony](http://www.symfony-project.org/) 1.3/1.4
* [Doctrine](http://www.doctrine-project.org/) 1.2

Список задач
------------
1. Реализовать настройку для генерации форм отдельно для конкретного приложения.
2. Уменьшить количество генерируемых файлов и минимизировать наследование классами-пустышками,
когда базовый класс формы например наследуется пустым классом. Ресурсы, хоть и небольшие,
но потребляются.
3. Добавить подробный лог действий генератора и возможность выбора, какой тип лога выводить.
4. Улучшить читабельность конфигурации виджетов/валидаторов за счет распознавания типов данных.

**Данный документ в процессе доработки и будет дописываться в ближайшее время, поскольку содержит
мало примеров и описывает не весь функционал плагина. Следите за изменениями**